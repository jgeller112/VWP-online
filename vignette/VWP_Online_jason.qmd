---
    title: "VWP Online Processing"
    author:
      - name: Jason Geller
    date: last-modified
    format:
      html:
        self-contained: true
        anchor-sections: true
        code-tools: true
        code-fold: true
        fig-width: 6
        fig-height: 4
        code-block-bg: "#f1f3f5"
        code-block-border-left: "#31BAE9"
        mainfont: Source Sans Pro
        theme: journal
        toc: true
        toc-depth: 3
        toc-location: left
        captions: true
        cap-location: margin
        table-captions: true
        tbl-cap-location: margin
        reference-location: margin
      pdf:
        pdf-engine: lualatex
        toc: false
        number-sections: true
        number-depth: 2
        top-level-division: section
        reference-location: document
        listings: false
        header-includes:
          \usepackage{marginnote, here, relsize, needspace, setspace}
          \def\it{\emph}

    comments:
      hypothesis: false

    execute:
      warning: false
      message: false
---

This tutorial demonstrates how to analyze online eye-tracking data from Gorilla. The data is taken from a sample version of the visual world paradigm where Target, Cohort, Rhyme, and and Unrelated (TCRU) pictures are presented in one of the four quadrants on the screen (top left, top right, bottom right, bottom left) randomly. A spoken word is presented after the pictures are presented on the screen and participants must select (with a mouse) which picture matched the spoken word.

::: callout-warning
There was some audio-visual lag so we delayed the audio by a couple hundred milliseconds. The pictures appeared on screen for 1500 ms and then the audio played. There is also a version where we did not do this.
:::

# Load Packages

Before turning to the code below, please install the packages by running the code below this paragraph. If you have already installed the packages mentioned below, then you can skip ahead and ignore this section. To install the necessary packages, simply run the following code - it may take some time (between 1 and 5 minutes to install all of the libraries so you do not need to worry if it takes some time).

```{r}
options(stringsAsFactors = F)          # no automatic data transformation

options("scipen" = 100, "digits" = 10) # suppress math annotation

library(tidyverse)

library(data.table)

library(here)

library(gazer)

library(knitr)

library(flextable)

library(tinytable)

```

# File Paths

Using the `here` package we get to grab our raw trial data from Gorilla. In addition we have the path to our trial-level data file we will also read in.

```{r}

vwp_files<-list.files(here::here("data", "uploads"), pattern = ".xlsx") # get files 

agg_eye_data <- read.csv(here::here("data", "data_exp_77588-v10_task-8vmc.csv"))

```

# Merge Files

With the below code we merge all the trials from each participant into one file saved to an object called `eye_data`

```{r}
#| echo: true
# merge all data files (gorilla stores each trial as one file for each p)
setwd(here::here("data", "uploads"))

  eye_data <- lapply(vwp_files,  readxl::read_excel)%>% 
    
    bind_rows() %>%
    
   dplyr::filter(type=="prediction") %>%
    
    dplyr::rename("trial" = "spreadsheet_row", "subject" = "participant_id", "time" = "time_elapsed") %>%
    
    dplyr::mutate(trial=factor(trial))%>%
    
     dplyr::select(subject, trial, time,face_conf, x_pred_normalised, y_pred_normalised)


count(eye_data, subject)

```

## Sampling rate

```{r}

edatSR <- eye_data  %>%
  dplyr::group_by(subject, trial) %>%
   dplyr::summarise(meanSR=1000/(max(time)/length(time)))

head(edatSR)

samp_average <- edatSR %>%
  group_by(subject) %>%
  summarise(avg_SR=mean(meanSR))

samp_average


```

# Trial-level Information

Gorilla produces a a `.csv` file that include trial-level information. Below we read that file in and create an object called `trial_data` that selects useful columns from that file and renames stimuli.

```{r}

#|message: false
#|echo: true
#|

trial_data <- agg_eye_data %>%

select(Participant.Private.ID,Trial.Number, Correct, targ_pic, cohort_pic, rhyme_pic, ur_pic, targ, cohort, rhyme, ur, Zone.Name, Zone.Type, targ_1, Experiment.Version, Reaction.Time) %>%

  filter(Zone.Type=="response_button_image")%>%

  #the coln names correspond to locations not actual pics. These are coded in other columns

  rename("TL" = "targ_pic", "BL" = "cohort_pic", "TR" = "rhyme_pic", "BR" = "ur_pic", "targ_loc"= "Zone.Name", "subject" = "Participant.Private.ID", "trial" ="Trial.Number", "acc" = "Correct", "RT" =
           "Reaction.Time") %>%
mutate(RT = as.numeric(RT)) %>% 

  distinct() %>%

  na.omit()


```

## Get Audio Onset Time

-   The audio was triggered 1500 ms after the onset. Gorilla records the onset of the audio which varies. We are extracting that here.

```{r}

 audio_rt <- agg_eye_data %>%

select(Participant.Private.ID,Zone.Type, Trial.Number, Reaction.Time) %>%

  filter(Zone.Type=="content_web_audio")%>%
  distinct() %>%
rename("subject" = "Participant.Private.ID", "trial" ="Trial.Number",  "RT_audio" =
           "Reaction.Time") %>%
select(-Zone.Type) %>%
mutate(RT_audio=as.numeric(RT_audio))
```

```{r}

trial_data_rt <- merge(trial_data, audio_rt, by=c("subject", "trial"))

head(trial_data_rt)

```

```{r}
 head(trial_data_rt) %>% 
flextable() %>%
  flextable::set_table_properties(width = .5, layout = "autofit") %>%
  flextable::theme_zebra() %>%
  flextable::fontsize(size = 12) %>%
  flextable::fontsize(size = 12, part = "header") %>%
  flextable::align_text_col(align = "center") %>%
  flextable::set_caption(caption = "")  %>%
  flextable::border_outer()
```

# Zone Coordinates

In the lab, we can control every aspect of the experiment. Online we cant do this. Participants are going to be completing the experiment under a variety of conditions. This includes using different computers, with very different screen dimensions. To control for this, Gorilla outputs standardized zone coordinates. In the current data, (in our case: top left, bottom left, top right, bottom right).

Below we are going to create a a data frame with our AOI locations and dimensions on the screen. This will be used in conjunction with the gazeR function `assign_aoi` which will loop through our data and assign whether an AOI was fixated or not.

```{r}
aoi_loc <- data.frame(loc = c("TL", "BL", "TR", "BR"),
           x_normalized = c(0.0202, 0.0300,0.73, .73),
           y_normalized = c(0.74,.04 , .75, .06),
           width_normalized = c(0.26,0.26, 0.24, 0.23),
           height_normalized = c(0.25,0.25, 0.24, 0.23)) %>% 
  mutate(xmin = x_normalized, ymin = y_normalized,
         xmax = x_normalized+width_normalized,
         ymax = y_normalized+height_normalized)

tinytable::tt(aoi_loc)
```

## Matching Conditions with Screen Locations

We need to know the condition (i.e., Target, Cohort, Rhyme, Unrelated) of each image shown as well as the location of each image on every trial.

```{r}

c=trial_data_rt %>% 
select(-Zone.Type, -targ_1, -targ, -cohort, -rhyme, -ur, -targ_loc) %>%
 pivot_longer(TL:BR, names_to="loc_screen")

c2=trial_data_rt %>% select(-Zone.Type, -targ_1, -TL, -TR, -BL, -BR, -targ_loc) %>% pivot_longer(targ:ur, names_to = "cond")


pic_merge <- merge(c, c2, by=c("subject", "trial", "acc", "value", "RT",  "RT_audio")) # have to merge loc of pictures 

kable(head(pic_merge))


rt=pic_merge %>%
  summarise(rt=mean(RT))

```

Once we have this we merge it with `eye_data`. We then arrange the data, pivot our `condition` variable to wide from long, and filter out incorrect responses and low confidence values.

```{r}

edatibs <- left_join(eye_data,pic_merge, by = c("subject", "trial"))


edatibs1 <- edatibs %>%
  arrange(subject, trial, time)%>%
  select(-value)%>%
  pivot_wider(names_from = cond, values_from = "loc_screen")%>%
  select(-"NA") %>%
  filter(face_conf >= .5, acc==1, Experiment.Version.x==10)

head(edatibs1)
```

Here is where we are going to use our coordinate information from above. We use the `gazer` function `assign_aoi` to loop through our object `edatibs1` and assign locations (i.e., TR, TL, BL, BR) to our normalized `x` and `y` coordinates. To make it easier to read we change the numerals assigned by the function to actual screen locations.

```{r}

center=.5#center of screen
distance=0#distance to visual stimuli
beyond_screen=1 #distance to beyond_screen


all_data<-edatibs1 %>%
 mutate(image_viewing=
 case_when(x_pred_normalised <= center-distance &
 y_pred_normalised >= center+distance ~ "TL",
 x_pred_normalised >= center+distance &
 y_pred_normalised >= center+distance ~ "TR",
 x_pred_normalised <= center-distance &
 y_pred_normalised <= center-distance ~ "BL", 
 x_pred_normalised >= center+distance &
 y_pred_normalised <= center-distance ~ "BR"))%>%
filter(!is.na(image_viewing))

all_data<-all_data %>%
 mutate(target_pic = if_else(image_viewing == targ, 1, 0),
 unrelated_pic = if_else(image_viewing == ur, 1, 0),
rhyme_pic = if_else(image_viewing ==  rhyme, 1, 0),
 cohort_pic  = if_else(image_viewing == cohort, 1, 0))%>%
filter(x_pred_normalised>center-beyond_screen &
x_pred_normalised<center+beyond_screen&
y_pred_normalised>center-beyond_screen &
y_pred_normalised<center+beyond_screen)

```

```{r}
AOI <- all_data  %>% 
select(-targ,-ur, -cohort, -rhyme)%>%
  pivot_longer(target_pic:cohort_pic, names_to="condition", values_to="fix" ) %>% 
  filter(acc==1)

head(AOI)

```

```{r}


gaze_obj <- AOI %>% 
dplyr::mutate(Fix=replace_na(fix, FALSE))
  
gaze_sub <- gaze_obj %>% 
group_by(subject, trial) %>%
mutate(audio_onset=time-RT_audio) %>% 
 filter(audio_onset >= -200, audio_onset <=1000) %>% 
  mutate(bin= 100*floor(audio_onset/100)) %>% # timebin
ungroup() %>% 
  group_by(condition, bin) %>%
  summarise(meanfix = mean(fix, na.rm = TRUE))


kable(head(gaze_sub))


```

```{r}

assign <- gazer::assign_aoi(edatibs1,screen_size = c(1,1),X="x_pred_normalised", Y="y_pred_normalised",aoi_loc = aoi_loc)



AOI <- assign %>%

  mutate(loc1 = case_when(

    AOI==1 ~ "TL", 

    AOI==2 ~ "BL", 

    AOI==3 ~ "TR", 

    AOI==4 ~ "BR"

  ))%>%

  arrange(subject, trial, time)

head(AOI)


```

In the `AOI` object we have our condition variables as columns. For this example, the fixation locations need to be "gathered" from separate columns into a single column and "NA" values need to be re-coded as non-fixations. We logically evaluate these below so we know which item was fixated each sample and what was not.

```{r}

AOI$target <- AOI$loc1 == AOI$targ

AOI$unrelated <- AOI$loc1 == AOI$ur


AOI$r <- AOI$loc1 == AOI$rhyme


AOI$co <- AOI$loc1 == AOI$cohort


AOI <- AOI %>% 
select(-targ,-ur, -cohort, -rhyme)%>%
  pivot_longer(target:co, names_to="condition", values_to="fix" ) %>% 
  filter(acc==1)

head(AOI)
```

## Non-looks

There are two ways we can handle missingness here. We can either re-code the NA values as non-looks, or we can exclude looks that occurred outside an AOI.

Here we are going to treat non-looks as missing variables and exclude them. If you wanted to re-code NAs as non-looks you can run the below code. The column `Fix` assigns non-looks as FALSE. The column `fix` treats all non-looks as NAs.

```{r}

gaze_obj <- AOI %>% 
dplyr::mutate(Fix=replace_na(fix, FALSE))
  
kable(head(gaze_obj))

```

# Samples to Bins

Researchers may decide to down sample their data. Here we down sample to 200 ms bins and get the aggregate across time and condition for plotting. We will end up with proportion looks to each of the AOIs which is stored in the `meanfix` column.

::: callout-warning
Here we filter the data to start at 1500 ms and end at 4000 ms. The reason for this is that we delay the start of the audio so it is not played before the presentation of the images.
:::

```{r}

gaze_sub <- gaze_obj %>% 
group_by(subject, trial) %>%
mutate(audio_onset=time-RT_audio) %>% 
 filter(audio_onset>=0, audio_onset<=1000) %>% 
  mutate(bin= 200*floor(audio_onset/200)) %>% # timebin
ungroup() %>% 
  group_by(condition, bin) %>%
  summarise(meanfix = mean(fix, na.rm = TRUE))


kable(head(gaze_sub))


```

# Plotting

We subset our data by only including data between 200 ms and 5000 ms. Things seem to be a bit delayed in the online version of the VWP.

```{r}

gaze_subj1 <- gaze_sub  %>% 
  
ggplot() +

  aes(x=bin,y=meanfix, color=condition) + 
  
  geom_line()


 gaze_subj1           

```

We see that the data is very noisy, but we do see a higher proportion of looks to the target at about 1 s post audio onset

```{r}
sessionInfo()
```

# Target Same Location

# File Paths

Using the `here` package we get to grab our raw trial data from Gorilla. In addition we have the path to our trial-level data file we will also read in.

```{r}

vwp_files<-list.files(here::here("data", "target_same_loc_data", "uploads"), pattern = ".xlsx") # get files 

agg_eye_data <- read.csv(here::here("data","target_same_loc_data",  "data_exp_77588-v12_task-8vmc.csv"))

```

# Merge Files

With the below code we merge all the trials from each participant into one file saved to an object called `eye_data`

```{r}
#| echo: true
# merge all data files (gorilla stores each trial as one file for each p)
setwd(here::here("data","target_same_loc_data",  "uploads"))

  eye_data <- lapply(vwp_files,  readxl::read_excel)%>% 
    
    bind_rows() %>%
    
   dplyr::filter(type=="prediction") %>%
    
    dplyr::rename("trial" = "spreadsheet_row", "subject" = "participant_id", "time" = "time_elapsed") %>%
    
    dplyr::mutate(trial=factor(trial))%>%
    
     dplyr::select(subject, trial, time,face_conf, x_pred_normalised, y_pred_normalised)


count(eye_data, subject)

```

## Sample rate

```{r}


edatSR <- eye_data  %>%
  dplyr::group_by(subject, trial) %>%
   dplyr::summarise(meanSR=1000/(max(time)/length(time)))

head(edatSR)


```

# Trial-level Information

Gorilla produces a a `.csv` file that include trial-level information. Below we read that file in and create an object called `trial_data` that selects useful columns from that file and renames stimuli.

```{r}

#|message: false
#|echo: true
#|

trial_data <- agg_eye_data %>%

select(Participant.Private.ID,Trial.Number, Correct, targ_pic, cohort_pic, rhyme_pic, ur_pic, targ, cohort, rhyme, ur, Zone.Name, Zone.Type, targ_1, Experiment.Version, Reaction.Time) %>%

  filter(Zone.Type=="response_button_image")%>%

  #the coln names correspond to locations not actual pics. These are coded in other columns

  rename("TL" = "targ_pic", "BL" = "cohort_pic", "TR" = "rhyme_pic", "BR" = "ur_pic", "targ_loc"= "Zone.Name", "subject" = "Participant.Private.ID", "trial" ="Trial.Number", "acc" = "Correct", "RT" =
           "Reaction.Time") %>%
mutate(RT = as.numeric(RT)) %>% 

  distinct() %>%

  na.omit()


```

## Get Audio Onset Time

-   The audio was triggered immediately after the onset. Gorilla records the onset of the audio which varies. We are extracting that here.

```{r}

 audio_rt <- agg_eye_data %>%

select(Participant.Private.ID,Zone.Type, Trial.Number, Reaction.Time) %>%

  filter(Zone.Type=="content_web_audio")%>%
  distinct() %>%
rename("subject" = "Participant.Private.ID", "trial" ="Trial.Number",  "RT_audio" =
           "Reaction.Time") %>%
select(-Zone.Type) %>%
mutate(RT_audio=as.numeric(RT_audio))
```

```{r}
trial_data_rt <- merge(trial_data, audio_rt, by=c("subject", "trial"))

head(trial_data_rt)
```

```{r}
 head(trial_data_rt) %>% 
flextable() %>%
  flextable::set_table_properties(width = .5, layout = "autofit") %>%
  flextable::theme_zebra() %>%
  flextable::fontsize(size = 12) %>%
  flextable::fontsize(size = 12, part = "header") %>%
  flextable::align_text_col(align = "center") %>%
  flextable::set_caption(caption = "")  %>%
  flextable::border_outer()

```

# Zone coordinates

In the lab, we can control every aspect of the experiment. Online we cant do this. Participants are going to be completing the experiment under a variety of conditions. This includes using different computers, with very different screen dimensions. To control for this, Gorilla outputs standardized zone coordinates. In the current data, (in our case: top left, bottom left, top right, bottom right).

Below we are going to create a a data frame with our AOI locations and dimensions on the screen. This will be used in conjunction with the gazeR function `assign_aoi` which will loop through our data and assign whether an AOI was fixated or not.

```{r}
aoi_loc <- data.frame(loc = c("TL", "BL", "TR", "BR"),
           x_normalized = c(0.0202, 0.0300,0.73, .73),
           y_normalized = c(0.74,.04 , .75, .06),
           width_normalized = c(0.26,0.26, 0.24, 0.23),
           height_normalized = c(0.25,0.25, 0.24, 0.23)) %>% 
  mutate(xmin = x_normalized, ymin = y_normalized,
         xmax = x_normalized+width_normalized,
         ymax = y_normalized+height_normalized)

tinytable::tt(aoi_loc)
```

## Bramlett and Wiener Pipeline

```{r}

center=.5#center of screen
distance=0#distance to visual stimuli
beyond_screen=1 #distance to beyond_screen


all_data<-edatibs_1_1 %>%
 mutate(image_viewing=
 case_when(x_pred_normalised <= center-distance &
 y_pred_normalised >= center+distance ~ "TL",
 x_pred_normalised >= center+distance &
 y_pred_normalised >= center+distance ~ "TR",
 x_pred_normalised <= center-distance &
 y_pred_normalised <= center-distance ~ "BL", 
 x_pred_normalised >= center+distance &
 y_pred_normalised <= center-distance ~ "BR"))%>%
filter(!is.na(image_viewing))

all_data<-all_data %>%
 mutate(target_pic = if_else(image_viewing == "TL", 1, 0),
 unrelated_pic = if_else(image_viewing == "BR", 1, 0),
rhyme_pic = if_else(image_viewing == "TR", 1, 0),
 cohort_pic = if_else(image_viewing == "BL", 1, 0))%>%
filter(x_pred_normalised>center-beyond_screen &
x_pred_normalised<center+beyond_screen&
y_pred_normalised>center-beyond_screen &
y_pred_normalised<center+beyond_screen)

```

```{r}

AOI <- all_data  %>% 
select(-targ,-ur, -cohort, -rhyme)%>%
  pivot_longer(target_pic:cohort_pic, names_to="condition", values_to="fix" ) %>% 
  filter(acc==1)

head(AOI)

```

```{r}

gaze_obj <- AOI %>% 
dplyr::mutate(Fix=replace_na(fix, FALSE))
  
gaze_sub <- gaze_obj %>% 
group_by(subject, trial) %>%
mutate(audio_onset=time-RT_audio) %>% 
 filter(audio_onset >= 0, audio_onset <=1000) %>% 
  mutate(bin= 50*floor(audio_onset/50)) %>% # timebin
ungroup() %>% 
  group_by(condition, bin) %>%
  summarise(meanfix = mean(fix, na.rm = TRUE))


kable(head(gaze_sub))
```

## Sampling rate

```{r}

# histogram with added parameters
hist(edatSR_part$avgSR_part,
#main="The Distribution of Participants' Sampling Rate",
xlab="Sampling Rate (Hz)",
xlim=c(0,35),
col="cyan3",
freq=TRUE
)

```

```{r}

gaze_subj1 <- gaze_sub %>%
       

ggplot() +

  aes(x=bin,y=meanfix, color=condition) + 
  
  geom_line()


gaze_subj1
```

## Matching conditions with screen locations

We need to know the condition (i.e., Target, Cohort, Rhyme, Unrelated) of each image shown as well as the location of each image on every trial.

```{r}

c=trial_data_rt %>% 
select(-Zone.Type, -targ_1, -targ, -cohort, -rhyme, -ur, -targ_loc) %>%
 pivot_longer(TL:BR, names_to="loc_screen")

c2=trial_data_rt %>% select(-Zone.Type, -targ_1, -TL, -TR, -BL, -BR, -targ_loc) %>% pivot_longer(targ:ur, names_to = "cond")


pic_merge <- merge(c, c2, by=c("subject", "trial", "acc", "value", "RT",  "RT_audio")) # have to merge loc of pictures 

kable(head(pic_merge))


rt=pic_merge %>%
  summarise(rt=mean(RT))

```

Once we have this we merge it with `eye_data`. We then arrange the data, pivot our `condition` variable to wide from long, and filter out incorrect responses and low confidence values.

```{r}

edatibs_1 <- merge(eye_data,pic_merge)

edatibs_1_1 <- edatibs_1 %>%
  arrange(subject, trial, time)%>%
  pivot_wider(names_from = cond, values_from = "loc_screen")%>%
  filter(face_conf >= .5, acc==1, Experiment.Version.x==12)

head(edatibs_1_1)
```

Here is where we are going to use our coordinate information from above. We use the `gazer` function `assign_aoi` to loop through our object `edatibs1` and assign locations (i.e., TR, TL, BL, BR) to our normalized `x` and `y` coordinates. To make it easier to read we change the numerals assigned by the function to actual screen locations.

```{r}

assign <- gazer::assign_aoi(edatibs_1_1,screen_size = c(1,1),X="x_pred_normalised", Y="y_pred_normalised",aoi_loc = aoi_loc)

 

AOI <- assign %>%

  mutate(loc1 = case_when(

    AOI==1 ~ "TL", 

    AOI==2 ~ "BL", 

    AOI==3 ~ "TR", 

    AOI==4 ~ "BR"

  ))%>%

  arrange(subject, trial, time)

head(AOI)


```

In the `AOI` object we have our condition variables as columns. For this example, the fixation locations need to be "gathered" from separate columns into a single column and "NA" values need to be re-coded as non-fixations. We logically evaluate these below so we know which item was fixated each sample and what was not.

```{r}

AOI$target <- AOI$loc1 == AOI$targ

AOI$unrelated <- AOI$loc1 == AOI$ur


AOI$r <- AOI$loc1 == AOI$rhyme


AOI$co <- AOI$loc1 == AOI$cohort


AOI <- AOI %>% 
select(-targ,-ur, -cohort, -rhyme)%>%
  pivot_longer(target:co, names_to="condition", values_to="fix" ) %>% 
  filter(acc==1)

head(AOI)
```

## Non-looks

There are two ways we can handle missingness here. We can either re-code the NA values as non-looks, or we can exclude looks that occurred outside an AOI.

Here we are going to treat non-looks as missing variables and exclude them. If you wanted to re-code NAs as non-looks you can run the below code. The column `Fix` assigns non-looks as FALSE. The column `fix` treats all non-looks as NAs.

```{r}


gaze_obj <- AOI %>% 
dplyr::mutate(Fix=replace_na(fix, FALSE))
  

kable(head(gaze_obj))

```

# Samples to Bins

Researchers may decide to down sample their data. Here we down sample to 200 ms bins and get the aggregate across time and condition for plotting. We will end up with proportion looks to each of the AOIs which is stored in the `meanfix` column.

::: callout-warning
Here we filter the data to start at 1500 ms and end at 4000 ms. The reason for this is that we delay the start of the audio so it is not played before the presentation of the images.
:::

```{r}

gaze_sub <- gaze_obj %>% 
group_by(subject, trial) %>%
mutate(audio_onset=time-RT_audio) %>% 
 filter(audio_onset >= 0, audio_onset <=1000) %>% 
  mutate(bin= 50*floor(audio_onset/50)) %>% # timebin
ungroup() %>% 
  group_by(condition, bin) %>%
  summarise(meanfix = mean(fix, na.rm = TRUE))


kable(head(gaze_sub))


```

# Plotting

We subset our data by only including data between 200 ms and 5000 ms. Things seem to be a bit delayed in the online version of the VWP.

```{r}

gaze_subj1 <- gaze_sub %>%
       

ggplot() +

  aes(x=bin,y=meanfix, color=condition) + 
  
  geom_line()


 gaze_subj1           

```
